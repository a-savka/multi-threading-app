# Анализ производительности файловых операций ввода-вывода в Java

В этом отчете подробно сравнивается производительность трех различных методов файлового ввода-вывода в Java: `RandomAccessFile`, `FileChannel` и Memory-Mapped Files (файлы, отображаемые в память). Тесты проводились в соответствии с требованиями задания.

## 1. Подготовка тестовых данных

Тестовый набор данных был сгенерирован с помощью класса `DataGenerator`. Каждая запись представляет собой строку с информацией о враче в формате: `ID={id},Name={name},Specialty={specialty}\n`.

Данные генерировались в памяти в виде `List<String>`, а затем записывались на диск с использованием тестируемого метода ввода-вывода. Тесты проводились для 10 000, 50 000 и 100 000 записей.

```java
// Фрагмент кода из DataGenerator.java
public static List<String> generateRecords(int recordCount) {
    List<String> records = new ArrayList<>(recordCount);
    for (int i = 0; i < recordCount; i++) {
        records.add("ID=" + i + ",Name=Dr. " + generateRandomName() + ",Specialty=" + generateRandomSpecialty() + "\n");
    }
    return records;
}
```

## 2. Реализация методов ввода-вывода

Для каждого метода были реализованы отдельные классы-тестеры.

### A. RandomAccessFile

Этот подход использует традиционный класс `RandomAccessFile` для чтения и записи. Он прост в использовании и предоставляет удобный способ перемещения к любой позиции в файле.

```java
// Запись с помощью RandomAccessFile
try (RandomAccessFile raf = new RandomAccessFile(filePath, "rw")) {
    for (String record : records) {
        raf.writeBytes(record);
    }
}
```

### B. FileChannel

Этот метод использует `FileChannel`, полученный из `RandomAccessFile`. Данные записываются и читаются через `ByteBuffer`, что обеспечивает больший контроль и потенциально лучшую производительность по сравнению с прямым потоковым вводом-выводом.

```java
// Запись с помощью FileChannel
try (RandomAccessFile raf = new RandomAccessFile(filePath, "rw");
     FileChannel channel = raf.getChannel()) {
    for (String record : records) {
        byte[] bytes = record.getBytes();
        ByteBuffer buffer = ByteBuffer.allocate(bytes.length);
        buffer.put(bytes);
        buffer.flip();
        while(buffer.hasRemaining()) {
            channel.write(buffer);
        }
    }
    channel.force(true); // принудительная запись на диск
}
```

### C. Memory-Mapped File (MMF)

Этот продвинутый подход отображает область файла непосредственно в память с помощью `FileChannel.map()`. Это позволяет обращаться к файлу так, как если бы он был большим массивом в памяти, что может привести к значительному увеличению производительности, особенно при произвольном доступе.

```java
// Запись с помощью Memory-Mapped File
try (RandomAccessFile raf = new RandomAccessFile(filePath, "rw");
     FileChannel channel = raf.getChannel()) {
    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, totalSize);
    for (String record : records) {
        buffer.put(record.getBytes());
    }
}
```

## 3. Результаты тестов

В таблицах ниже представлены результаты тестов производительности. Все временные показатели указаны в миллисекундах (ms).

### Производительность записи (ms)

| Кол-во записей | RandomAccessFile | FileChannel | MemoryMappedFile |
|----------------|------------------|-------------|------------------|
| **10,000**     | 86               | 187         | 9                |
| **50,000**     | 351              | 542         | 9                |
| **100,000**    | 415              | 1484        | 42               |

### Производительность чтения (ms) для 100,000 записей

| Тип чтения      | RandomAccessFile | FileChannel | MemoryMappedFile |
|-----------------|------------------|-------------|------------------|
| **Последовательное**| 5991             | 2           | 2                |
| **Случайное**   | 23               | 3           | 0                |

### Приблизительное потребление памяти (МБ)

| Кол-во записей | RandomAccessFile | FileChannel | MemoryMappedFile |
|----------------|------------------|-------------|------------------|
| **10,000**     | -103             | 1           | 1                |
| **50,000**     | 17               | 8           | 8                |
| **100,000**    | -40              | 17          | 20               |

*Примечание по потреблению памяти:* Измерения проводились с помощью `Runtime.totalMemory() - Runtime.freeMemory()`. Этот метод не является абсолютно точным и может зависеть от работы сборщика мусора. Отрицательные значения для `RandomAccessFile`, вероятно, указывают на то, что между измерениями произошла сборка мусора, которая освободила больше памяти, чем было выделено во время теста. Это подчеркивает неточность данного метода измерения.

## 4. Анализ и выводы

### Сравнение производительности
- **Скорость записи:** Memory-Mapped Files показали себя как самый быстрый способ для записи, часто с огромным отрывом. `RandomAccessFile` занял второе место, в то время как `FileChannel` с созданием буфера для каждой записи оказался самым медленным. Накладные расходы на выделение `ByteBuffer` для каждой записи и вызов `force()` вероятно, способствовали снижению производительности `FileChannel`.
- **Скорость чтения:** Для последовательного чтения `FileChannel` и MMF были значительно быстрее, чем `RandomAccessFile`. Метод `readLine()` в `RandomAccessFile` известен своей неэффективностью. Для случайного чтения Memory-Mapped Files стали абсолютным победителем, обеспечивая практически мгновенный доступ, поскольку файл рассматривается как массив в памяти.

### Memory-Mapped Files и RAM
Файлы, отображаемые в память, делегируют управление памятью операционной системе. ОС лениво загружает страницы файла в память по мере обращения к ним. Это может быть очень эффективно, так как загружаются только необходимые части файла. Однако это также может привести к высокому потреблению ОЗУ, если отображается большой файл, поскольку ОС будет использовать доступную физическую память для его кэширования. Использование памяти, о котором сообщает JVM (`Runtime`), не полностью отражает память, используемую ОС для отображения, поэтому фактический объем занимаемой памяти может быть больше.

### Сценарии использования `RandomAccessFile`
`RandomAccessFile` лучше всего подходит для сценариев, где:
- Простота важнее, чем максимальная производительность.
- Необходимо выполнять небольшие, нечастые и случайные обновления большого файла без сложностей, связанных с отображением в память.
- Файл слишком велик для безопасного отображения в доступное адресное пространство (актуально для 32-битных систем, в меньшей степени для 64-битных).

### Риски и соображения
- **Освобождение ресурсов:** У MMF есть свои особенности в части освобождения ресурсов. Отображение остается активным до тех пор, пока объект `MappedByteBuffer` не будет собран сборщиком мусора. Явного метода `unmap()` не существует, что может затруднить удаление базового файла в некоторых ОС (особенно в Windows) до завершения работы JVM. 
- **Синхронизация:** При использовании режима `READ_WRITE` для MMF, одновременный доступ из нескольких потоков должен быть синхронизирован вручную для предотвращения повреждения данных, как и при работе с любой разделяемой памятью.
- **Безопасность:** Запись в `MappedByteBuffer` напрямую изменяет файл на диске. Сбой программы может оставить файл в поврежденном состоянии. Метод `force()` у `FileChannel` предоставляет более явный контроль над тем, когда данные надежно записываются на устройство хранения.