## 1. Общее описание приложения

### Тип приложения

**Многопоточный парсер курсов валют** — приложение для автоматического сбора, обработки и предоставления актуальных данных о курсах валют из различных внешних источников (банки, биржи, API).

### Основная функциональность

- Периодический сбор данных о курсах валют из нескольких внешних API и веб-источников.
- Обработка и нормализация данных (JSON, XML, CSV).
- Сохранение актуальных и исторических данных в базу.
- Предоставление REST API для получения текущих и исторических курсов.
- Поддержка уведомлений об значительных изменениях курсов.

### Ключевые технологии

- **Backend:** Spring Boot 3.x, Java 21
- **База данных:** PostgreSQL (хранение исторических данных и метаинформации)
- **Многопоточность:** `CompletableFuture`, `@Async`, ограниченные пулы потоков через `ThreadPoolTaskExecutor`
- **Внешние взаимодействия:** REST клиенты (WebClient, RestTemplate), парсинг HTML (Jsoup)
- **Мониторинг:** Micrometer, Prometheus, Loki для логов
- **Сборка:** Maven/Gradle, Docker

### Архитектура

**Монолит** — учитывая сравнительно узкую специализацию приложения (парсинг и предоставление данных), отсутствие необходимости в независимом масштабировании отдельных функций и цель снижения операционной сложности, выбрана монолитная архитектура. Все компоненты (парсинг, бизнес-логика, API) развертываются как единое целое.

### Ресурсоемкие операции

1. **Сетевые вызовы:** Многократные параллельные HTTP-запросы к внешним API банков и бирж.
2. **Парсинг данных:** Обработка больших XML/JSON ответов или HTML-страниц.
3. **Работа с БД:** Массовая вставка (batch insert) накопленных данных за период, сложные аналитические запросы к историческим данным.
4. **Вычисления:** Расчет производных показателей (средние курсы, изменения за период) по историческим данным.

------

## 2. Анализ потенциальных проблем

### Категория 1: Аппаратный уровень

#### 1.1 Нехватка CPU при парсинге большого JSON/XML

- **Как может проявиться:** При получении объемного ответа от внешнего API (например, список курсов по всем валютам за год) синхронный парсинг может надолго занять поток и увеличить общее время отклика системы, особенно если такие запросы приходят параллельно.
- **Обоснование опасений:** Опасения **умеренные**. Парсинг стандартных JSON-ответов о текущих курсах обычно нетяжелый. Однако риск возникает при сборе больших объемов исторических данных или при обработке "тяжелых" XML-форматов от некоторых источников.
- **Обнаружение и предотвращение:**
  - **Обнаружение:** Использование **Micrometer** для замера времени выполнения методов парсинга и мониторинг загрузки CPU через **VisualVM** или **Prometheus/Grafana**.
  - **Предотвращение:**
    1. Использование асинхронной обработки (`@Async`) для выгрузки и первичного парсинга больших данных, чтобы не блокировать основные потоки.
    2. Оптимизация алгоритмов парсинга (например, использование streaming API для JSON/XML вместо полной загрузки в память).
    3. Установка разумных таймаутов на HTTP-запросы к источникам.

#### 1.2 Сетевая пропускная способность (частые запросы к внешнему API)

- **Как может проявиться:** При слишком частом опросе десятков внешних источников (каждые 10 секунд) можно столкнуться с ограничениями сетевого интерфейса или исчерпать лимиты запросов со стороны провайдеров API.
- **Обоснование опасений:** Опасения **высокие**. Это основная операция приложения. Неправильная настройка частоты запросов и их параллельного выполнения может привести к блокировкам IP или потере данных.
- **Обнаружение и предотвращение:**
  - **Обнаружение:** Логирование статус-кодов и времени ответов внешних служб. Мониторинг счетчиков сетевого трафика на сервере.
  - **Предотвращение:**
    1. Реализация **Circuit Breaker** (например, Resilience4j) для исключения "забивания" запросов к недоступным или медленным источникам.
    2. Конфигурируемые интервалы опроса для каждого источника (например, для важных банков — раз в минуту, для второстепенных — раз в 5 минут).
    3. Использование пула соединений (HTTP client connection pooling) для эффективного повторного использования соединений.

### Категория 2: Контекстное переключение (Context Switching)

#### 2.1 Слишком много потоков (например, по одному на каждый источник валют)

- **Как может проявиться:** Если создать отдельный поток для каждого внешнего API (или для каждой валютной пары), при большом количестве источников (>50) накладные расходы на переключение контекста между потоками могут съесть всю выгоду от параллельности. Это приведет к высокой загрузке CPU без реальной полезной работы.
- **Обоснование опасений:** Опасения **средние**. При грамотной настройке пула потоков риск минимален. Без нее — высокий.
- **Обнаружение и предотвращение:**
  - **Обнаружение:** **VisualVM** или **Java Mission Control** отлично показывают количество активных потоков и состояние пулов. Высокий показатель `% CPU kernel time` может указывать на активное переключение.
  - **Предотвращение:**
    1. **Отказ от `newCachedThreadPool()`.** Использование фиксированного (`newFixedThreadPool`) или ограниченного пула через `ThreadPoolTaskExecutor` в Spring.
    2. Размер пула должен быть основан не на количестве источников, а на оптимальном числе для сетевых IO-задач. Формула `N_threads = N_cores * (1 + Wait_time / Compute_time)`. Для задач, связанных с ожиданием сети, пул может быть в несколько раз больше числа ядер.
    3. Использование **асинхронных неблокирующих клиентов** (WebClient), которые более эффективно используют ресурсы за счет меньшего количества потоков.

### Категория 3: Архитектурный выбор

#### 3.1 Почему выбран монолит?

- **Как проявляется выбор:** Все сервисы (парсинг, хранение, API) развернуты вместе. Масштабирование происходит путем запуска нескольких копий всего приложения.
- **Обоснование выбора (почему не опасаемся):**
  1. **Простота разработки и деплоя:** Один кодовая база, один процесс для развертывания и отладки.
  2. **Связность данных:** Данные парсинга тесно связаны с сервисом предоставления API. В микросервисной архитектуре пришлось бы организовывать сложную синхронизацию между сервисом данных и API-шлюзом, что избыточно для данной задачи.
  3. **Производительность:** Внутримонолитные вызовы происходят быстрее, чем сетевые RPC между микросервисами, что критично для актуальности данных при конвертации.
- **Обеспечение согласованности данных:** В рамках монолита используется транзакционность **Spring `@Transactional`** при сохранении данных. Актуальный курс для конвертации всегда берется из единственного источника истины — основной таблицы в БД, куда пишутся результаты последнего успешного парсинга. Это гарантирует сильную согласованность в рамках одного инстанса приложения.

#### 3.2 Риски монолитной архитектуры

- **Как может проявиться:** По мере роста функциональности (добавление аналитики, уведомлений, панели администрирования) кодовая база может стать слишком сложной для поддержки. Отказ одного компонента (например, зависший парсер) может привести к падению всего приложения, включая REST API.
- **Обнаружение и предотвращение:**
  - **Обнаружение:** Логирование здоровья отдельных функциональных модулей. Мониторинг размера и сложности кодовой базы.
  - **Предотвращение:**
    1. Четкое модульное разделение кода внутри монолита по принципам **DDD** (Domain-Driven Design).
    2. Вынесение особенно ресурсоемких или нестабильных задач (например, парсинг специфического источника) в отдельные, изолированные **исполнительные пулы потоков**, чтобы их сбои не влияли на критическую функциональность.
    3. Готовность к возможному стратегическому выделению функционально законченных модулей (например, "Сервис уведомлений") в отдельные микросервисы в будущем, если в этом возникнет бизнес-необходимость.