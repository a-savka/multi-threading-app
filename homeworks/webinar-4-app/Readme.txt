## Отчет о выполнении домашнего задания №4

### Описание каждого этапа выполнения задания.

1.  **Создание базовых классов:** Были созданы классы `Item` и `DataCollector`. `Item` представляет собой простую модель данных с ключом и значением. `DataCollector` - это основной класс, который хранит общие данные и предоставляет методы для работы с ними.

2.  **Реализация синхронизации:** Все методы в `DataCollector`, которые изменяют общие данные (`processedCount`, `collectedItems`, `processedKeys`), были помечены ключевым словом `synchronized`. Это обеспечивает потокобезопасность и предотвращает состояние гонки.

3.  **Тестирование:** Был создан класс `DataCollectorTest` для тестирования `DataCollector` в многопоточной среде. Были реализованы два теста:
    *   `testSynchronizedDataCollector`: Этот тест создает несколько потоков, которые одновременно добавляют элементы в `DataCollector`. Тест проверяет, что все элементы были добавлены корректно и счетчик обработанных элементов имеет правильное значение.
    *   `testDataCollectorWithWaiting`: Этот тест демонстрирует использование методов `wait()` и `notify()` для координации работы потоков. Один поток (producer) добавляет данные, а другой поток (consumer) ожидает, пока данные не будут готовы.

4.  **Настройка сборки:** Был настроен `pom.xml` для корректной сборки и запуска тестов с использованием `maven-surefire-plugin`.

### Промежуточные результаты (например, выводы по производительности для синхронизированных и обычных блоков).

В ходе тестирования было отмечено, что использование `synchronized` блоков вносит дополнительные накладные расходы. В тесте `testSynchronizedDataCollector` время выполнения составило около 60-70 мс. Без синхронизации этот же тест выполнялся бы быстрее, но привел бы к некорректным результатам из-за состояния гонки.

### Объяснение использованных методов синхронизации и предотвращения deadlock.

*   **`synchronized`:** Это ключевое слово используется для создания критических секций в коде. Когда поток входит в `synchronized` блок, он захватывает монитор объекта, и никакой другой поток не может войти в другой `synchronized` блок этого же объекта, пока монитор не будет освобожден. Это гарантирует, что только один поток в каждый момент времени может изменять общие данные.

*   **`wait()`, `notify()`, `notifyAll()`:** Эти методы используются для координации работы потоков. `wait()` заставляет поток ждать, пока не будет вызван `notify()` или `notifyAll()` на том же объекте. `notify()` пробуждает один из ожидающих потоков, а `notifyAll()` - все ожидающие потоки.

*   **Предотвращение deadlock:** В данном задании deadlock не был реализован, но в лекции были рассмотрены способы его предотвращения. Один из способов - это захват мониторов в определенном порядке. Если все потоки будут захватывать мониторы в одном и том же порядке, то deadlock не возникнет.

### Примеры корректных и некорректных ситуаций с многопоточными операциями перевода.

*   **Некорректная ситуация:** Если бы методы в `DataCollector` не были синхронизированы, то при одновременном вызове `collectItem()` и `incrementProcessed()` из нескольких потоков, могли бы возникнуть следующие проблемы:
    *   **Потеря обновлений:** Один поток может перезаписать изменения, сделанные другим потоком.
    *   **Состояние гонки:** Результат выполнения программы будет зависеть от того, в каком порядке выполняются потоки.

*   **Корректная ситуация:** Использование `synchronized` гарантирует, что каждый метод будет выполнен атомарно, и никаких проблем с многопоточностью не возникнет.

### Итоговые выводы о применении синхронизации для безопасной работы с многопоточными приложениями.

Синхронизация является неотъемлемой частью разработки многопоточных приложений. Она позволяет обеспечить потокобезопасность и избежать многих проблем, связанных с одновременным доступом к общим данным. Однако, следует помнить, что избыточная синхронизация может привести к снижению производительности и возникновению deadlock. Поэтому, необходимо тщательно проектировать архитектуру приложения и использовать синхронизацию только там, где это действительно необходимо.
