# Отчет о выполнении задания 13

## Описание

В рамках задания была реализована многопоточная система для асинхронной обработки URL-адресов. Система имитирует работу сервера задач, где один поток-производитель поставляет задачи (URL) в очередь, а несколько потоков-потребителей извлекают их и обрабатывают.

## Этапы выполнения

### 1. Анализ задачи и проектирование

Задача состояла в том, чтобы создать приложение, которое:
- Использует `BlockingQueue` для обмена данными между потоками.
- Имеет **Производителя**, который добавляет URL-адреса в очередь.
- Имеет **Потребителей**, которые скачивают веб-страницы по URL и извлекают их заголовки (`<title>`).

Было решено использовать `LinkedBlockingQueue<String>` для хранения URL, так как она является потокобезопасной и хорошо подходит для сценариев "Производитель-Потребитель".

Для управления потоками был выбран `ExecutorService` с фиксированным пулом потоков (`Executors.newFixedThreadPool`).

### 2. Реализация компонентов

**`Producer.java`**
- Класс содержит статический список из 20 URL-адресов для обработки.
- В методе `run()` он последовательно добавляет каждый URL в `BlockingQueue` с небольшой задержкой, имитируя поступление задач.
- После добавления всех URL, производитель отправляет в очередь специальное сообщение-маркер (`STOP_SIGNAL`) для каждого потребителя. Этот маркер сигнализирует потребителям о том, что новых задач больше не будет, и они могут завершить свою работу.

**`Consumer.java`**
- Потребитель в бесконечном цикле пытается извлечь URL из очереди с помощью метода `take()`, который блокирует поток, если очередь пуста.
- При получении маркера `STOP_SIGNAL`, потребитель выходит из цикла и завершает работу.
- Для каждого полученного URL:
    1. Устанавливается `HttpURLConnection`.
    2. Выполняется GET-запрос для скачивания содержимого страницы.
    3. С помощью регулярного выражения `(<title>(.*?)</title>)` из HTML-кода извлекается заголовок страницы.
    4. Результат выводится в консоль.
- Реализована базовая обработка ошибок, таких как таймауты подключения и ошибки чтения.

**`Webinar13Application.java`**
- Главный класс приложения, который оркеструет весь процесс.
- Создает `BlockingQueue` и `ExecutorService`.
- Запускает одного производителя и три потребителя (`CONSUMER_COUNT = 3`).
- Использует `executorService.shutdown()` для инициации graceful shutdown (плавного завершения), после чего новые задачи не принимаются, а уже запущенные продолжают выполняться.
- `executorService.awaitTermination()` используется для ожидания завершения всех потоков в пуле. Это гарантирует, что основная программа не завершится раньше, чем все URL будут обработаны.

### 3. Результат

Приложение успешно запускается, асинхронно обрабатывает список URL и корректно завершает работу после выполнения всех задач. В консоли отображаются логи производителя, добавляющего URL в очередь, и логи потребителей, которые параллельно извлекают заголовки веб-страниц.
