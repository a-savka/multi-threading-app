# Отчет о выполнении задания: Введение в проект Loom (Virtual Threads)

## 1. Описание каждого этапа выполнения задания

### 1.1. Создание задач

Была создана программа, которая выполняет 10 000 одинаковых задач. Каждая задача имитирует I/O-операцию с помощью `Thread.sleep(Duration.ofSeconds(1))` и выводит в консоль имя потока, в котором она выполняется.

### 1.2. Использование платформенных потоков

Для выполнения задач были использованы платформенные потоки. Для управления потоками был создан `ExecutorService` с помощью `Executors.newThreadPerTaskExecutor(platformThreadFactory)`. Этот экзекьютор создает новый платформенный поток для каждой задачи.

```java
private static void runPlatformThreads() {
    ThreadFactory platformThreadFactory = Thread.ofPlatform().name("platform-thread-", 0).factory();
    try (ExecutorService executor = Executors.newThreadPerTaskExecutor(platformThreadFactory)) {
        for (int i = 0; i < NUMBER_OF_TASKS; i++) {
            executor.submit(() -> {
                System.out.println("Выполняется задача в платформенном потоке: " + Thread.currentThread().getName());
                try {
                    Thread.sleep(Duration.ofSeconds(1));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
    }
}
```

### 1.3. Использование виртуальных потоков и StructuredTaskScope

Для выполнения тех же задач были использованы виртуальные потоки. Для создания и управления виртуальными потоками использовался `StructuredTaskScope`. Каждая задача запускалась в новом виртуальном потоке с помощью `scope.fork()`.

`StructuredTaskScope` позволяет дождаться завершения всех запущенных задач с помощью метода `join()` и обработать возможные исключения с помощью `throwIfFailed()`.

```java
private static void runVirtualThreadsWithScope() {
    ThreadFactory virtualThreadFactory = Thread.ofVirtual().name("virtual-thread-", 0).factory();
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
        for (int i = 0; i < NUMBER_OF_TASKS; i++) {
            scope.fork(() -> {
                System.out.println("Выполняется задача в виртуальном потоке: " + Thread.currentThread().getName());
                Thread.sleep(Duration.ofSeconds(1));
                return null;
            });
        }
        scope.join();
        scope.throwIfFailed();
    } catch (Exception e) {
        // Exception handling
    }
}
```

### 1.4. Сравнение производительности

Для сравнения производительности измерялось время выполнения всех 10 000 задач для обоих подходов. Для измерения времени использовался класс `Instant`.

## 2. Промежуточные результаты

При запуске программы в консоль выводится информация о выполнении каждой задачи и времени выполнения для каждого типа потоков.

Время выполнения для платформенных потоков было значительно больше, чем для виртуальных. Это связано с тем, что создание платформенного потока - дорогостоящая операция, и их количество ограничено ресурсами операционной системы.

Время выполнения для виртуальных потоков было близко к 1 секунде (время выполнения одной задачи), так как все задачи выполнялись параллельно.

## 3. Итоговые выводы

Виртуальные потоки (Project Loom) предоставляют легковесную альтернативу традиционным платформенным потокам в Java. Они позволяют писать асинхронный код в синхронном стиле, что значительно упрощает разработку и поддержку многопоточных приложений.

Основные преимущества виртуальных потоков:

- **Масштабируемость:** Можно создавать миллионы виртуальных потоков без значительных накладных расходов.
- **Производительность:** Для I/O-связанных задач виртуальные потоки показывают значительно лучшую производительность по сравнению с платформенными потоками.
- **Простота:** Код, написанный с использованием виртуальных потоков, выглядит как обычный синхронный код, что упрощает его чтение и отладку.

`StructuredTaskScope` предоставляет удобный и надежный способ управления группой виртуальных потоков, обеспечивая их корректное завершение и обработку ошибок.

В результате выполнения данного задания было наглядно продемонстрировано преимущество использования виртуальных потоков для выполнения большого количества I/O-связанных задач.
