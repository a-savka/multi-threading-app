## Отчет о выполнении домашнего задания №6

### Описание каждого этапа выполнения задания.

1.  **Реализация остановки потока через `volatile`:**
    *   Создан класс `VolatileExample` с `volatile boolean` флагом `running`.
    *   Метод `start()` запускает новый поток, который работает в цикле `while (running)`.
    *   Метод `stop()` устанавливает флаг `running` в `false`, что приводит к завершению цикла и остановке потока.

2.  **Реализация потокобезопасного счетчика через `AtomicInteger`:**
    *   Создан класс `AtomicCounter` с полем `AtomicInteger`.
    *   Метод `increment()` атомарно увеличивает значение счетчика.
    *   Метод `getValue()` возвращает текущее значение счетчика.

3.  **Реализация потокобезопасной структуры данных (singleton-кэш) через `AtomicReference`:**
    *   Создан класс `SingletonCache` с полем `AtomicReference<String>`.
    *   Метод `getValue()` использует `compareAndSet()` для атомарного обновления значения кэша. Если значение `null`, оно создается и кэшируется.

4.  **Тестирование:**
    *   В классе `Webinar6Application` реализован `CommandLineRunner`, который демонстрирует работу всех трех классов.
    *   Для `VolatileExample` запускается поток, который останавливается через 2 секунды.
    *   Для `AtomicCounter` создается пул из 10 потоков, которые 1000 раз инкрементируют счетчик. В конце выводится итоговое значение.
    *   Для `SingletonCache` создается пул из 5 потоков, которые 10 раз обращаются к кэшу.

### Объяснение использования `volatile`, `AtomicInteger` и `AtomicReference` в контексте потокобезопасности.

*   **`volatile`:** Модификатор `volatile` гарантирует, что все потоки будут видеть актуальное значение переменной. Он предотвращает кэширование значения переменной в кэше процессора каждого потока. Это полезно для переменных, которые могут быть изменены одним потоком и прочитаны другим, как в случае с флагом остановки потока.

*   **`AtomicInteger`:** Класс `AtomicInteger` предоставляет атомарные операции для `int` значения. Это означает, что операции, такие как инкремент, выполняются как одна неделимая операция, что исключает состояние гонки. Это более эффективная альтернатива использованию `synchronized` для простых операций со счетчиками.

*   **`AtomicReference`:** Класс `AtomicReference` предоставляет атомарные операции для ссылочных типов. Он позволяет атомарно обновлять ссылку на объект. Метод `compareAndSet()` позволяет реализовать оптимистичные блокировки, что может быть более производительным, чем использование `synchronized`.

### Примеры корректных и некорректных ситуаций с многопоточными операциями.

*   **Некорректная ситуация (без `volatile`):** Если бы флаг `running` в `VolatileExample` не был `volatile`, то поток мог бы никогда не увидеть изменения этого флага и продолжал бы работать бесконечно.

*   **Некорректная ситуация (без `AtomicInteger`):** Если бы для счетчика использовался обычный `int` и операция инкремента не была бы синхронизирована, то итоговое значение счетчика было бы непредсказуемым и, скорее всего, меньше 1000, так как некоторые операции инкремента были бы потеряны.

*   **Корректная ситуация:** Использование `volatile`, `AtomicInteger` и `AtomicReference` обеспечивает потокобезопасность и корректное выполнение программы в многопоточной среде.

### Итоговые выводы о применении `volatile` и `Atomic`-переменных в многозадачных приложениях.

`volatile` и `Atomic`-переменные являются важными инструментами для написания корректных и эффективных многопоточных приложений. Они предоставляют легковесные механизмы синхронизации, которые могут быть более производительными, чем `synchronized` блоки.

*   `volatile` следует использовать для переменных, которые разделяются между потоками, когда один поток пишет, а другие читают.
*   `Atomic`-классы следует использовать для реализации потокобезопасных счетчиков, генераторов последовательностей и других структур данных, которые требуют атомарных операций.

Использование этих инструментов позволяет писать более чистый, читаемый и производительный многопоточный код.
