# Отчет о выполнении задания 12

## Описание

В рамках задания была реализована многопоточная система обработки событий с использованием шаблона "Производитель-Потребитель" (Producer-Consumer).

## Реализация

Система состоит из следующих компонентов:

- **`Event.java`**: Простой POJO класс, представляющий событие. Содержит `id` и `message`.

- **`BlockingQueue<Event>`**: В качестве потокобезопасной коллекции для обмена событиями между производителями и потребителями была выбрана `java.util.concurrent.LinkedBlockingQueue`. Эта блокирующая очередь идеально подходит для данного сценария, так как она эффективно управляет синхронизацией, блокируя поток-потребитель, если очередь пуста, и поток-производитель, если очередь заполнена (в случае ограниченной очереди).

- **`Producer.java`**: Класс, реализующий `Runnable`. Он генерирует новые события и помещает их в `BlockingQueue` с помощью метода `put()`. Для генерации уникальных ID событий используется `AtomicInteger`.

- **`Consumer.java`**: Класс, реализующий `Runnable`. Он извлекает события из `BlockingQueue` с помощью метода `take()` и "обрабатывает" их (в данном случае, выводит в консоль).

- **`Webinar12Application.java`**: Главный класс приложения. Он выполняет следующие действия:
    1. Создает `LinkedBlockingQueue` с ограниченной вместимостью.
    2. Создает `ExecutorService` с фиксированным пулом потоков для управления производителями и потребителями.
    3. Запускает одного производителя и двух потребителей.
    4. Позволяет системе работать в течение 10 секунд.
    5. Корректно завершает работу `ExecutorService` с помощью `shutdownNow()` и `awaitTermination()`, как рекомендовано в лекции для избежания "зависших" потоков.

## Результат

Приложение успешно демонстрирует работу многопоточной системы, где один поток-производитель создает события, а два потока-потребителя параллельно их обрабатывают. Использование `BlockingQueue` и `ExecutorService` позволило создать надежное и эффективное решение в соответствии с лучшими практиками, описанными в лекции.
