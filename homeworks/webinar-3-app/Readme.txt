## Отчет о выполнении домашнего задания

### Описание каждого этапа выполнения задания.

1.  **Создание списка**: Был создан список из 1 000 000 случайных целых чисел с использованием `java.util.Random`.
2.  **Последовательная обработка**: Список был обработан с использованием `stream()`:
    *   **Фильтрация**: Отфильтрованы только четные числа (`n % 2 == 0`).
    *   **Преобразование**: Каждое число умножено на 2.
    *   **Агрегация**: Найдена сумма всех чисел после фильтрации и преобразования.
    *   **Измерение времени**: Замерено время выполнения всех операций.
3.  **Параллельная обработка**: Список был обработан с использованием `parallelStream()` с выполнением тех же операций фильтрации, преобразования и агрегации. Время выполнения также было замерено.
4.  **Вывод результатов**: Результаты (сумма и время выполнения) для обоих подходов были выведены в консоль.

### Промежуточные результаты

*   **Сумма (последовательно):** -1198825536188
*   **Время выполнения (последовательно):** 37 мс
*   **Сумма (параллельно):** -1198825536188
*   **Время выполнения (параллельно):** 24 мс

### Объяснение причин различий в производительности

`parallelStream()` работает значительно быстрее, чем обычный `stream()` для больших наборов данных. Причина в том, что `parallelStream()` использует внутренний пул потоков (`ForkJoinPool.commonPool()`) для разделения коллекции на несколько частей и обработки этих частей одновременно на разных ядрах процессора.

В данном случае, операции фильтрации, отображения и суммирования являются независимыми для каждого элемента, что делает их идеальными для распараллеливания. Система может эффективно распределить работу между доступными ядрами, что приводит к существенному сокращению общего времени выполнения.

Последовательный `stream()` обрабатывает все элементы в одном потоке, один за другим. Это просто и предсказуемо, но не использует всю мощь многоядерных процессоров.

### Итоговые выводы

*   **`stream()` (последовательный)**: Лучше всего использовать для:
    *   Небольших наборов данных, где накладные расходы на распараллеливание могут превысить выгоду.
    *   Операций, которые являются последовательными (например, зависят от порядка элементов).
    *   Когда важна простота и предсказуемость выполнения.

*   **`parallelStream()` (параллельный)**: Лучше всего использовать для:
    *   Больших наборов данных (сотни тысяч и более элементов).
    *   Вычислительно интенсивных операций, которые можно легко распараллелить (независимые операции над элементами).
    *   Когда производительность является критическим фактором и доступно несколько ядер процессора.

### Примечания о влиянии параллелизма и параллельности на производительность

*   **Параллелизм**: Это одновременное выполнение нескольких задач. `parallelStream` достигает истинного параллелизма, выполняя код на нескольких ядрах процессора одновременно.
*   **Конкурентность**: Это способ структурирования программы для управления несколькими задачами одновременно. Хотя `parallelStream` является примером параллелизма, он также управляет конкурентным доступом к данным, хотя в данном примере этого не требуется, так как операции независимы.

Использование `parallelStream` не всегда гарантирует ускорение. Если операции включают в себя много блокировок или если набор данных слишком мал, производительность может даже ухудшиться из-за накладных расходов на управление потоками.
