# Отчет о выполнении домашнего задания по теме "Работа сборщика мусора (GC) и управление памятью"

## Описание задания

Цель этого задания — симулировать утечку памяти в Java-приложении, проанализировать поведение сборщика мусора (GC) и исследовать состояние памяти с помощью различных инструментов.

## Шаги выполнения

### 1. Создание приложения с утечкой памяти

Для выполнения задания было модифицировано базовое Spring Boot приложение.

**Файл:** `src/main/java/ru/savka/Performance2Application.java`

```java
package ru.savka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.ArrayList;
import java.util.List;

@SpringBootApplication
public class Performance2Application {

    private static final List<Object> memoryLeak = new ArrayList<>();

    public static void main(String[] args) throws InterruptedException {
        SpringApplication.run(Performance2Application.class, args);
        System.out.println("Приложение запущено. Начинаем симуляцию утечки памяти.");

        while (true) {
            for (int i = 0; i < 1000; i++) {
                memoryLeak.add(new byte[1024 * 10]); // 10 KB
            }
            System.out.println("Добавлено 1000 объектов в список. Текущий размер списка: " + memoryLeak.size());
            Thread.sleep(1000);
        }
    }
}
```

В этом коде в бесконечном цикле в статический список `memoryLeak` добавляются массивы байт. Поскольку на этот список всегда есть сильная ссылка, сборщик мусора не может удалить добавленные объекты, что приводит к утечке памяти и в конечном итоге к ошибке `OutOfMemoryError`.

### 2. Запуск приложения с логированием GC

Для запуска приложения и анализа его поведения необходимо включить логирование сборки мусора. Это делается с помощью специальных флагов JVM.

**Команда для сборки:**

Сначала необходимо собрать проект с помощью Maven.

```bash
./mvnw clean package
```

**Команда для запуска с логированием GC:**

```bash
java -Xlog:gc*:file=gc.log:tags,time,uptime,level -jar target/performance-app-2-0.0.1-SNAPSHOT.jar
```

- `-Xlog:gc*:file=gc.log:tags,time,uptime,level`: Этот флаг включает логирование GC и направляет вывод в файл `gc.log`.

### 3. Анализ логов GC

После запуска приложения файл `gc.log` начнет заполняться информацией о работе сборщика мусора.

**Пример содержимого `gc.log`:**

```
[2025-11-22T12:00:00.123+0000][1.234s][info][gc] GC(0) Pause Young (Allocation Failure) 1024M->512M(2048M) 123.456ms
[2025-11-22T12:00:01.456+0000][2.567s][info][gc] GC(1) Pause Full (Ergonomics) 1536M->1024M(2048M) 456.789ms
```

**Анализ:**

- **Pause Young**: Сборка мусора в молодом поколении (Young Generation).
- **Pause Full**: Полная сборка мусора (Old Generation).
- **1024M->512M(2048M)**: Использование heap-памяти до сборки -> после сборки (общий размер heap).

В случае утечки памяти мы будем наблюдать, что после каждой полной сборки мусора (Full GC) объем используемой памяти не уменьшается значительно, а продолжает расти, пока не достигнет предела.

Для более детального анализа логов можно использовать утилиту **GCViewer**.

### 4. Анализ Heap Dump

Для глубокого анализа состояния памяти необходимо создать Heap Dump — снимок всей heap-памяти в определенный момент времени.

**Создание Heap Dump:**

1.  **Узнать PID процесса:**
    ```bash
    jps
    ```
2.  **Создать дамп с помощью `jcmd`:**
    ```bash
    jcmd <pid> GC.heap_dump /path/to/heap.hprof
    ```

**Анализ с помощью VisualVM или Eclipse MAT:**

Полученный файл `heap.hprof` можно открыть в **VisualVM** или **Eclipse Memory Analyzer (MAT)**.

- **VisualVM**: Позволяет в реальном времени мониторить использование CPU, памяти, потоки и классы. Можно подключиться к запущенному приложению и увидеть график роста heap-памяти.
- **Eclipse MAT**: Мощный инструмент для анализа heap dump. Он помогает найти "утечки" памяти, показывая объекты, которые занимают больше всего места, и пути ссылок, которые мешают сборщику мусора их удалить. При анализе нашего дампа MAT покажет, что класс `Performance2Application` имеет статическое поле `memoryLeak` (типа `ArrayList`), которое содержит огромное количество объектов `byte[]` и занимает почти всю память.

### Выводы

Данное упражнение демонстрирует классический пример утечки памяти в Java. Анализ логов GC и heap dump позволяет точно определить источник проблемы.

- **Проблема:** Неконтролируемое добавление объектов в статическую коллекцию, на которую всегда существует сильная ссылка.
- **Решение:** В реальном приложении необходимо было бы пересмотреть логику работы с этой коллекцией: очищать ее, когда данные больше не нужны, или использовать слабые/мягкие ссылки (`WeakReference`, `SoftReference`), если это применимо.

Это задание наглядно показывает важность правильного управления памятью и полезность инструментов профилирования для поддержания производительности и стабильности приложений.
