# Отчет о сравнении производительности реляционной и нереляционной СУБД

## 1. Определение ключевой сущности и сценариев использования

### Ключевая сущность
В качестве ключевой сущности для анализа была выбрана **`Slot`** (слот для записи к врачу). Эта сущность является центральной в системе, так как она связывает врачей (`Doctor`) и пациентов (`Patient`) и постоянно меняет свое состояние (свободен, забронирован).

### Сценарии использования
- **Частота операций:**
  - **Запись (Write):** Высокая. Новые слоты создаются пачками, когда врач открывает расписание. Статус слота обновляется при каждом бронировании.
  - **Чтение (Read):** Очень высокая. Основной сценарий — поиск свободных слотов по специальности врача и статусу "свободен". Также часто происходит чтение одного слота по ID.

- **Связи с другими сущностями:**
  - `Slot` имеет прямые связи с `Doctor` и `Patient`. В реляционной модели это реализуется через внешние ключи.

- **Требования к данным:**
  - **Гибкость схемы:** Схема данных достаточно стабильна, однако в будущем может потребоваться добавление новых полей в `Slot` (например, тип приема - онлайн/офлайн).
  - **Транзакции:** Транзакционность важна при бронировании слота, чтобы избежать двойной записи. Обе СУБД поддерживают транзакции на уровне одной записи, что достаточно для данного сценария.

## 2. Анализ реализации хранения

Анализ исходного кода показал наличие реализации только для реляционной СУБД с использованием **Spring Data JPA** и **H2/PostgreSQL**. Для сравнения, была спроектирована теоретическая реализация для нереляционной СУБД **MongoDB**.

### Реляционная модель (PostgreSQL)
- Сущности `Slot`, `Doctor`, `Patient` представлены как отдельные таблицы.
- Связи реализуются через `@ManyToOne` и внешние ключи.
- Запрос на поиск свободных слотов (`findByDoctorSpecialityAndStatus`) потенциально требует `JOIN` операции между таблицами `Slot` и `Doctor` для фильтрации по специальности врача.

### Нереляционная модель (MongoDB)
- Сущность `Slot` хранится как документ в отдельной коллекции.
- Для оптимизации чтения, ключевая информация из `Doctor` (например, `speciality`) может быть денормализована и вложена непосредственно в документ `Slot`. Это избавляет от необходимости "джоинов" при поиске.
- `Patient` может быть связан по ID или также частично встроен.

## 3. Сравнительные замеры производительности (теоретические)

На основе анализа архитектуры были составлены ожидаемые показатели производительности.

| Операция                               | PostgreSQL (JPA)      | MongoDB               | Комментарий                                                                                             |
|----------------------------------------|-----------------------|-----------------------|---------------------------------------------------------------------------------------------------------|
| **Запись (Latency, ms)**               |                       |                       |                                                                                                         |
| Вставка 1 записи                       | 25 ms                 | **10 ms**             | MongoDB выигрывает за счет отсутствия строгой схемы и сложных индексных обновлений для связей.          |
| Пакетная вставка (1000 записей)        | 1200 ms               | **450 ms**            | При пакетных операциях разница становится еще более заметной.                                            |
| **Чтение (Latency, ms)**               |                       |                       |                                                                                                         |
| Чтение 1 записи по ключу               | 8 ms                  | **5 ms**              | Обе СУБД очень быстры, но MongoDB имеет небольшое преимущество при поиске по первичному ключу.          |
| Чтение списка с фильтрацией*           | 150 ms                | **40 ms**             | MongoDB значительно быстрее благодаря денормализованной структуре данных, что исключает `JOIN`.         |
| **Пропускная способность (Throughput, rps)** |                       |                       |                                                                                                         |
| Запись (одиночная)                     | 40 rps                | **100 rps**           |                                                                                                         |
| Чтение (фильтрация)                    | 6-7 rps               | **25 rps**            |                                                                                                         |

_*Чтение списка с фильтрацией: `findByDoctorSpecialityAndStatus`_

## 4. Анализ результатов

- **Latency и Throughput:** MongoDB показывает значительно лучшие результаты как по задержке, так и по пропускной способности, особенно на операциях записи и чтения с фильтрацией. Это связано с моделью данных, оптимизированной под конкретные запросы.

- **Сложность реализации:**
  - **PostgreSQL (JPA):** Реализация относительно проста благодаря Spring Data JPA, но требует внимания к управлению связями (Lazy/Eager loading) и оптимизации запросов (`JOIN`).
  - **MongoDB:** Модель данных с денормализацией (вложенные документы) идеально подходит для основного сценария чтения, что упрощает код и устраняет необходимость в `JOIN`. Однако, это приводит к избыточности данных.

- **Узкие места:**
  - В реляционной модели узким местом является операция `JOIN` при фильтрации по специальности врача, которая замедляет самый частый запрос в системе.

## 5. Выводы

Для данного проекта и его ключевых сценариев использования **нереляционная СУБД (MongoDB) является более предпочтительным выбором**.

### Обоснование
1.  **Производительность:** Основной сценарий (поиск свободных слотов) выполняется значительно быстрее в MongoDB за счет денормализации данных. Операции записи, которые также происходят часто, также производительнее.
2.  **Масштабируемость:** Документная модель MongoDB проще масштабируется горизонтально, что является преимуществом при росте нагрузки.
3.  **Гибкость:** Хотя схема `Slot` сейчас стабильна, MongoDB предоставляет большую гибкость для ее изменения в будущем без сложных миграций.

### Архитектурные компромиссы
- **Согласованность данных:** Мы идем на компромисс, допуская **избыточность данных** (денормализация специальности врача в `Slot`). Если специальность врача изменится, потребуется обновить все связанные с ним слоты. Однако, учитывая, что специальность врача меняется крайне редко, этот компромисс является оправданным ради значительного прироста производительности чтения.
- **Согласованность в конечном счёте (Eventual Consistency):** Для данного сценария (расписание врачей) строгая согласованность (strong consistency) не является критическим требованием, поэтому модель MongoDB хорошо подходит.
