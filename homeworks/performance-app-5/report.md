# Отчет о рефакторинге приложения на основе Hexagonal Architecture

## Введение

В рамках данного задания было произведено рефакторинг Spring Boot-приложения для записи к врачу с целью приведения его архитектуры в соответствие с принципами Hexagonal Architecture (гексагональной архитектуры).

Изначально приложение имело классическую слоеную архитектуру (controller, service, repository, entity), что приводило к сильной связанности бизнес-логики с инфраструктурными компонентами, такими как Spring Framework и JPA.

## Цели рефакторинга

- Выделить чистое доменное ядро, не зависящее от фреймворков и деталей реализации.
- Определить и реализовать "порты" для взаимодействия с ядром.
- Реализовать "адаптеры" для различных технологий (Web, gRPC, Persistence).
- Обеспечить возможность независимого тестирования доменного ядра.
- Продемонстрировать взаимозаменяемость адаптеров без изменения ядра.

## Реализованная архитектура

Новая структура проекта выглядит следующим образом:

```
/ru/savka/demo
├── domain
│   ├── model         // POJO-классы доменной области (Doctor, Patient, Slot)
│   ├── port
│   │   ├── in        // Входные порты (use cases), например, SlotUseCase
│   │   └── out       // Выходные порты (репозитории), например, SlotRepositoryPort
│   └── service       // Реализация входных портов (бизнес-логика), например, DomainSlotService
├── adapter
│   ├── persistence   // Адаптер для персистентности (JPA)
│   │   ├── entity
│   │   ├── mapper
│   │   └── repository
│   ├── web           // Адаптер для REST API
│   │   ├── controller
│   │   ├── dto
│   │   └── mapper
│   └── grpc          // Адаптер для gRPC
│       ├── GrpcSlotMapper.java
│       ├── GrpcDoctorMapper.java
│       └── SlotGrpcService.java
├── config            // Конфигурация Spring-бинов
└── ...
```

### 1. Доменное ядро

- **`domain/model`**: Содержит чистые Java-объекты (`Doctor`, `Patient`, `Slot`) без каких-либо аннотаций Spring, JPA или Lombok. Это обеспечивает полную независимость ядра от внешних технологий.
- **`domain/port/in`**: Определяет интерфейс `SlotUseCase`, который является "входным портом" и описывает, какие операции можно выполнять над доменной областью (например, `getFreeSlotsBySpeciality`, `reserveSlot`).
- **`domain/port/out`**: Содержит интерфейсы репозиториев (`SlotRepositoryPort`, `PatientRepositoryPort`), которые являются "выходными портами". Они определяют контракты для получения и сохранения данных, не раскрывая детали реализации.
- **`domain/service`**: `DomainSlotService` реализует `SlotUseCase` и содержит основную бизнес-логику. Он зависит только от интерфейсов выходных портов, но не от их конкретных реализаций.

### 2. Адаптеры

- **Persistence Adapter (`adapter/persistence`)**: Реализует выходные порты (`...RepositoryPort`). Он использует Spring Data JPA (`...Repository`) и JPA-сущности (`...entity`) для взаимодействия с базой данных. Мапперы преобразуют доменные модели в JPA-сущности и обратно.
- **Web Adapter (`adapter/web`)**: `SlotController` является "входящим" адаптером. Он зависит от входного порта `SlotUseCase` и использует его для выполнения бизнес-операций. DTO и мапперы используются для преобразования доменных моделей в формат, удобный для REST API.
- **gRPC Adapter (`adapter/grpc`)**: `SlotGrpcService` — это второй "входящий" адаптер. Как и веб-контроллер, он использует тот же `SlotUseCase` для доступа к бизнес-логике, но предоставляет интерфейс через gRPC. Это демонстрирует, как к одному и тому же ядру можно подключать разные технологии.

### 3. Взаимодействие слоев

Зависимости направлены строго внутрь, к доменному ядру:

`Adapters -> Domain Core`

Ядро (`domain`) ничего не знает об адаптерах (`adapter`). Вся конфигурация и связывание компонентов происходит в классе `BeanConfiguration` с помощью Spring Dependency Injection.

## Тестирование

Был написан юнит-тест `DomainSlotServiceTest` для доменного сервиса. В этом тесте зависимости (выходные порты) были заменены моками с использованием Mockito.

Это подтверждает, что **бизнес-логику можно тестировать в полной изоляции**, без необходимости запускать Spring-контекст, подключать базу данных или другие инфраструктурные компоненты. Тесты выполняются быстро и проверяют исключительно логику ядра.

## Выводы

Гексагональная архитектура позволила достичь следующих преимуществ:

1.  **Низкая связанность**: Бизнес-логика полностью отделена от деталей реализации (веб-фреймворк, база данных).
2.  **Высокая тестируемость**: Ядро можно тестировать независимо, что упрощает разработку и поддержку.
3.  **Гибкость и расширяемость**: Добавление нового адаптера (gRPC) не потребовало никаких изменений в доменном ядре. Аналогично, можно легко заменить реализацию репозитория (например, с JPA на JDBC или MongoDB), реализовав соответствующий адаптер для выходного порта.

Переход на гексагональную архитектуру делает приложение более устойчивым к изменениям в технологическом стеке и более простым для понимания и дальнейшего развития.