## Отчет о выполнении домашнего задания №5

### Описание каждого этапа выполнения задания.

1.  **Реализация `BoundedBuffer`:** Был создан класс `BoundedBuffer`, представляющий собой потокобезопасный буфер фиксированного размера. Для синхронизации доступа к буферу использовались `ReentrantLock` и `Condition`.

2.  **Использование `ReentrantLock`:** `ReentrantLock` был использован для явного управления блокировками. Методы `lock()` и `unlock()` применялись для защиты критических секций в методах `put()` и `take()`.

3.  **Использование `Condition`:** Были созданы два объекта `Condition` (`notFull` и `notEmpty`) для управления ожиданием и уведомлением потоков. `notFull.await()` используется, когда буфер полон, а `notEmpty.await()` - когда буфер пуст. `notFull.signal()` и `notEmpty.signal()` используются для уведомления ожидающих потоков.

4.  **Создание producer’ов и consumer’ов:** В классе `Webinar5Application` были созданы несколько потоков-продюсеров и потоков-консьюмеров, которые параллельно работают с `BoundedBuffer`.

5.  **Тестирование:** В `Webinar5Application` реализован демонстрационный запуск, который показывает взаимодействие продюсеров и консьюмеров. Этот запуск можно использовать для ручного тестирования и оценки производительности.

### Объяснение применения методов ReentrantLock и Condition для реализации потокобезопасных операций.

*   **`ReentrantLock`:** `ReentrantLock` предоставляет более гибкий и мощный механизм блокировки по сравнению с `synchronized`. Он позволяет устанавливать таймауты на ожидание блокировки, прерывать ожидающие потоки и получать информацию о состоянии блокировки. В `BoundedBuffer` `ReentrantLock` используется для защиты доступа к очереди `buffer`.

*   **`Condition`:** `Condition` отделяет ожидание от монитора объекта, что позволяет иметь несколько групп ожидающих потоков для одного и того же лока. В `BoundedBuffer` `notFull` используется для ожидания продюсеров, когда буфер полон, а `notEmpty` - для ожидания консьюмеров, когда буфер пуст.

### Примеры взаимодействия между потоками producer’ов и consumer’ов.

В `Webinar5Application` создаются 2 продюсера и 3 консьюмера. Продюсеры добавляют элементы в буфер, а консьюмеры их забирают. В консоли можно наблюдать, как продюсеры и консьюмеры работают параллельно, и как буфер заполняется и опустошается.

### Итоговые выводы о преимуществах и недостатках использования ReentrantLock и Condition по сравнению с традиционными методами синхронизации.

**Преимущества `ReentrantLock` и `Condition`:**

*   **Гибкость:** `ReentrantLock` предоставляет больше возможностей по сравнению с `synchronized`, такие как прерываемые и временные блокировки.
*   **Производительность:** В некоторых случаях `ReentrantLock` может обеспечивать лучшую производительность, особенно в условиях высокой конкуренции.
*   **Несколько условий:** `Condition` позволяет иметь несколько условий ожидания для одной блокировки, что упрощает реализацию сложных сценариев синхронизации.

**Недостатки:**

*   **Сложность:** Использование `ReentrantLock` и `Condition` требует более аккуратного и внимательного программирования. Необходимо всегда освобождать блокировку в блоке `finally`, чтобы избежать deadlock.
*   **Многословность:** Код с `ReentrantLock` и `Condition` может быть более многословным, чем с `synchronized`.

В целом, `ReentrantLock` и `Condition` являются мощными инструментами для создания сложных и высокопроизводительных многопоточных приложений. Однако, для простых случаев синхронизации, `synchronized` может быть более простым и удобным решением.
