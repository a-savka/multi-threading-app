# Отчёт о настройке инструментов для анализа производительности

## 1. Введение

В рамках работы над проектом была создана и настроена система для мониторинга и анализа производительности многопоточного приложения. Цель настройки — получить возможность собирать метрики, находить узкие места и диагностировать проблемы с производительностью.

Система состоит из следующих компонентов:
-   **Micrometer:** библиотека для сбора метрик внутри приложения.
-   **Prometheus:** система для сбора и хранения метрик.
-   **Grafana:** платформа для визуализации метрик в виде дашбордов.
-   **Jaeger:** система для распределенной трассировки.
-   **VisualVM:** инструмент для профилирования и анализа работы JVM.

## 2. Настройка Micrometer

Micrometer был интегрирован в приложение для сбора различных метрик, таких как время ответа на запросы, использование памяти, нагрузка на процессор и кастомные бизнес-метрики (например, количество операций парсинга).

**Шаги интеграции:**

1.  **Добавление зависимостей:** В файл `pom.xml` были добавлены зависимости Spring Boot Actuator, который является "мостом" для Micrometer, и специальный модуль для интеграции с Prometheus.

    ```xml
    <!-- Зависимость для Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <!-- Зависимость для интеграции с Prometheus -->
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
        <scope>runtime</scope>
    </dependency>
    ```

2.  **Настройка эндпоинтов:** Чтобы Prometheus мог "забирать" метрики, в файле `application.properties` был открыт специальный эндпоинт `/actuator/prometheus`.

    ```properties
    # Открываем все эндпоинты Actuator, включая Prometheus
    management.endpoints.web.exposure.include=*
    ```

После этих шагов приложение начало самостоятельно собирать метрики и предоставлять их по адресу `http://localhost:8080/actuator/prometheus`.

## 3. Настройка Prometheus

Prometheus был настроен для периодического сбора метрик из нашего Spring Boot приложения.

**Шаги настройки:**

1.  **Создание конфигурационного файла:** Был создан файл `prometheus.yml`, который указывает Prometheus, откуда и как часто собирать данные.

    ```yaml
    global:
      scrape_interval: 15s # Собирать метрики каждые 15 секунд

    scrape_configs:
      - job_name: 'spring-app' # Имя нашего приложения
        metrics_path: '/actuator/prometheus' # Путь, по которому доступны метрики
        static_configs:
          - targets: ['host.docker.internal:8080'] # Адрес нашего приложения
    ```
    *Важно:* `host.docker.internal` используется для того, чтобы Docker-контейнер Prometheus мог "достучаться" до приложения, запущенного на хост-машине.

2.  **Запуск Prometheus:** Prometheus был запущен как Docker-контейнер с использованием созданного файла конфигурации.

    ```bash
    docker run --rm -d --name prometheus -p 9090:9090 \
      -v /path/to/project/multi-threading-app/prometheus.yml:/etc/prometheus/prometheus.yml \
      --add-host=host.docker.internal:host-gateway \
      prom/prometheus
    ```

После запуска Prometheus стал доступен по адресу `http://localhost:9090`, где можно выполнять запросы к собранным метрикам и проверять статус их сбора.

## 4. Настройка и использование Grafana

Grafana используется для того, чтобы в удобной и наглядной форме визуализировать метрики, собранные Prometheus.

**Шаги настройки:**

1. **Запуск Grafana:** Grafana была запущена как Docker-контейнер.
   ```bash
   docker run --rm -d --name grafana -p 3000:3000 --add-host=host.docker.internal:host-gateway grafana/grafana-oss
   ```

2. **Подключение к Prometheus:** В веб-интерфейсе Grafana (http://localhost:3000, логин/пароль: admin/admin) был добавлен Prometheus в качестве источника данных (Data Source). В качестве URL сервера был указан `http://host.docker.internal:9090`.

3. **Настройка дашборда:** Для быстрой визуализации метрик JVM а так же специфических метрик для анализа производительности парсинга были добавлены графики для визуализации следующих параметров приложения: `parsing_time_seconds_count, parsing_success_total,
   parsing_failure_total, db_records_inserted_total` трекинг которых был настроен в приложении.

   

## 5. Настройка и использование Jaeger

Jaeger был настроен для реализации распределенной трассировки. Это позволяет отслеживать путь выполнения запроса через всю систему и измерять время, затраченное на каждый отдельный этап (например, запрос к базе данных, парсинг и т.д.).

**Шаги настройки:**

1.  **Интеграция OpenTelemetry:** В `pom.xml` были добавлены зависимости OpenTelemetry, а в код (`ParserWorker`) — специальная логика для создания "спанов" (трассировочных отрезков) для ключевых операций. Имя сервиса было программно задано как `currency-rate-app` в классе `OpenTelemetryConfig`.

2.  **Запуск Jaeger:** Jaeger был запущен как Docker-контейнер с помощью образа "all-in-one".
    
    ```bash
    docker run -d --name jaeger \
      -e COLLECTOR_OTLP_ENABLED=true \
      -p 16686:16686 \
      -p 4318:4318 \
      jaegertracing/all-in-one:latest
    ```
    Порт `16686` используется для доступа к веб-интерфейсу, а `4318` — для приема данных от нашего приложения.
    
3.  **Анализ трейсов:** После запуска парсинга в приложении, в интерфейсе Jaeger (http://localhost:16686) стало возможным найти трейсы по имени сервиса `currency-rate-app`. Визуализация в виде диаграммы Ганта наглядно показывает, сколько времени занимает каждый этап парсинга,.

## 6. Использование VisualVM

VisualVM — это визуальный инструмент, который позволяет в реальном времени заглянуть "под капот" запущенного Java-приложения.

**Процесс подключения:**

1.  После запуска Java-приложения запускается VisualVM.
2.  В левой панели "Applications" автоматически появляется процесс нашего приложения.
3.  Двойной клик по процессу открывает панель с детальной информацией.

С помощью VisualVM проводился анализ использования CPU, памяти и состояния потоков. Этот инструмент оказался особенно полезным для профилирования и поиска узких мест, таких как частая сборка мусора и создание большого количества объектов.

## 7. Настройка JVM

На начальных этапах анализа производительности специальные настройки для виртуальной машины Java (JVM) не применялись. Приложение запускалось со стандартными параметрами JVM. Это позволило установить "базовый" уровень производительности и оценить эффект от оптимизаций кода и настроек без влияния дополнительных флагов JVM.